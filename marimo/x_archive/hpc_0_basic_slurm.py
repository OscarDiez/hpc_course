import marimo

__generated_with = "0.15.2"
app = marimo.App()


app._unparsable_cell(
    r"""
    # Introduction to HPC Clusters and SLURM

    This notebook is designed to help you understand what an HPC (High-Performance Computing) cluster is, how to use SLURM for job scheduling, and how to compile and run a simple C program on the cluster.

    ## Learning Objectives
    - Understand the architecture of HPC clusters.
    - Learn the basics of SLURM and its main commands.
    - Compile and run a simple C program using SLURM.
    - Perform practical exercises to reinforce the learned concepts.
    """,
    name="_"
)


app._unparsable_cell(
    r"""
    ## What is an HPC Cluster?
    An HPC cluster is a collection of interconnected computers (or nodes) that work together to perform complex computations. These clusters can handle computational tasks that require a lot of processing power and memory, far beyond what a single machine could manage.

    ### Architecture of HPC Clusters
    1. **Management Node**: Controls the overall operation of the cluster.
    2. **Login Node**: Provides an interface for users to submit jobs and interact with the cluster.
    3. **Compute Nodes**: Perform the actual computations.

    ### SLURM Overview
    SLURM (Simple Linux Utility for Resource Management) is a job scheduler that manages resources and queues jobs in an HPC cluster.
    """,
    name="_"
)


@app.cell(hide_code=True)
def _(mo):
    mo.md(
        r"""
        ### Basic SLURM Commands
        - `squeue`: View the job queue.
        - `sbatch`: Submit a batch job.
        - `salloc`: Allocate resources for a job.
        - `scancel`: Cancel a job.

        #### Example: Checking the Job Queue
        ```bash
        !squeue
        ```

        ### Exercise 1: Explore the Cluster

        **Task**: Use the SLURM command `sinfo` to list the available nodes and their states in the cluster.

        ```bash
        !sinfo
        ```

        **Question 1**: What is the state of the compute nodes in the cluster?
        - [ ] Idle
        - [ ] Allocated
        - [ ] Mixed
        - [ ] Down
        - [ ] Drained
        """
    )
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(
        r"""
        ## Creating and Compiling a Simple C Program

        Let's create a simple C program that calculates the sum of numbers from 1 to 100.

        ### C Program: sum.c
        ```c
        #include <stdio.h>

        int main() {
            int sum = 0;
            for (int i = 1; i <= 100; i++) {
                sum += i;
            }
            printf("Sum = %d\n", sum);
            return 0;
        }
        ```

        ### Compiling the C Program
        Use the GCC compiler to compile your C program.
        ```bash
        !gcc -o sum sum.c
        ```

        ### Exercise 2: Compile and Run the C Program

        **Task**: Compile and run the provided C program on the login node.

        **Question 2**: What is the output of the C program?
        - [ ] Sum = 100
        - [ ] Sum = 5050
        - [ ] Sum = 5000
        - [ ] Sum = 505
        - [ ] Compilation error
        """
    )
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(
        r"""
        ## Submitting Jobs with SLURM

        SLURM jobs can be submitted using batch scripts.

        ### Example Batch Script: job.sh
        ```bash
        #!/bin/bash
        #SBATCH --job-name=test_job
        #SBATCH --output=result.out
        #SBATCH --ntasks=1
        #SBATCH --time=00:05:00
        #SBATCH --partition=short

        ./sum
        ```

        ### Submitting the Job
        ```bash
        !sbatch job.sh
        ```

        ### Exercise 3: Submit a Job

        **Task**: Submit a job using the provided batch script and check the output.

        **Question 3**: What is the job ID of your submitted job?
        - [ ] 100
        - [ ] 101
        - [ ] 102
        - [ ] Check the SLURM output
        - [ ] Job submission failed
        """
    )
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(
        r"""
        ## Understanding SLURM Job Outputs

        After a job completes, SLURM generates output files based on the directives in the batch script.

        ### Exercise 4: Analyze Job Output

        **Task**: Examine the output file generated by your job and verify the result.

        **Question 4**: What is the content of the output file?
        - [ ] Error message
        - [ ] Sum = 5050
        - [ ] Sum = 5000
        - [ ] Empty file
        - [ ] Job failed
        """
    )
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(
        r"""
        ## Advanced SLURM Features

        SLURM offers advanced features such as job dependencies and array jobs.

        ### Exercise 5: Job Dependencies

        **Task**: Modify your batch script to run another job only after the current job completes successfully.

        **Question 5**: How do you specify job dependencies in SLURM?
        - [ ] `#SBATCH --after`
        - [ ] `#SBATCH --dependency=afterok:<job_id>`
        - [ ] `#SBATCH --depends=<job_id>`
        - [ ] `#SBATCH --wait=<job_id>`
        - [ ] `#SBATCH --follow=<job_id>`
        """
    )
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(
        r"""
        ### SLURM Array Jobs
        Array jobs allow you to submit multiple tasks with a single job script.

        ### Exercise 6: Array Job

        **Task**: Create a SLURM array job that runs the same C program for different input values.

        **Question 6**: What SLURM directive is used to create array jobs?
        - [ ] `#SBATCH --array=<n>`
        - [ ] `#SBATCH --tasks=<n>`
        - [ ] `#SBATCH --batch=<n>`
        - [ ] `#SBATCH --repeat=<n>`
        - [ ] `#SBATCH --loop=<n>`
        """
    )
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(
        r"""
        ## Monitoring and Managing Jobs

        Use SLURM commands to monitor and manage your jobs efficiently.

        ### Exercise 7: Monitor Job Progress

        **Task**: Use the SLURM command `scontrol` to check the status of your job.

        **Question 7**: What command can you use to view detailed information about your job?
        - [ ] `squeue --details`
        - [ ] `scontrol show job <job_id>`
        - [ ] `sinfo --verbose`
        - [ ] `sbatch --info`
        - [ ] `sstat --job=<job_id>`
        """
    )
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(
        r"""
        ## Exploring Cluster Resources

        Understanding the available resources in the cluster can help optimize your job submissions.

        ### Exercise 8: Resource Exploration

        **Task**: Use `scontrol` and `sinfo` to gather information about the cluster's resources.

        **Question 8**: Which command provides the most detailed information about the nodes?
        - [ ] `sinfo`
        - [ ] `scontrol show node`
        - [ ] `squeue --nodes`
        - [ ] `snodes`
        - [ ] `sstat --nodes`
        """
    )
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(
        r"""
        ## Debugging and Troubleshooting

        ### Exercise 9: Debugging SLURM Jobs

        **Task**: Learn how to troubleshoot common issues with SLURM jobs by checking error logs and output files.

        **Question 9**: Which SLURM command helps diagnose why a job did not start?
        - [ ] `squeue --errors`
        - [ ] `scontrol show job <job_id>`
        - [ ] `sbatch --debug`
        - [ ] `sinfo --problems`
        - [ ] `sdiag`
        """
    )
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(
        r"""
        ## Advanced C Programming on HPC

        ### Exercise 10: Optimize C Code for HPC

        **Task**: Modify the C program to use parallel computing techniques (like OpenMP) to improve performance.

        **Question 10**: Which compiler directive enables OpenMP in GCC?
        - [ ] `-fopenmp`
        - [ ] `-openmp`
        - [ ] `-omp`
        - [ ] `-fparallel`
        - [ ] `-mp`
        """
    )
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(
        r"""
        ## Summary

        In this notebook, you have learned about the basic components of an HPC cluster, how to use SLURM for job scheduling, and how to compile and run simple C programs. You've also explored more advanced features of SLURM and discussed some optimization techniques for C programs.

        ### Answers to Quiz Questions
        1. Idle
        2. Sum = 5050
        3. Check the SLURM output
        4. Sum = 5050
        5. `#SBATCH --dependency=afterok:<job_id>`
        6. `#SBATCH --array=<n>`
        7. `scontrol show job <job_id>`
        8. `scontrol show node`
        9. `scontrol show job <job_id>`
        10. `-fopenmp`

        ### Explanations
        1. The state of the compute nodes can be checked using `sinfo`, which displays their status.
        2. The output of the C program is calculated by summing numbers from 1 to 100, which equals 5050.
        3. The job ID is provided in the SLURM output after job submission.
        4. The output file contains the result of the executed C program.
        5. Job dependencies in SLURM are managed using the `--dependency` flag with the appropriate conditions.
        6. Array jobs are created using the `--array` directive in SLURM.
        7. Detailed job information can be obtained using `scontrol` with the job ID.
        8. Node details are best explored using `scontrol show node`.
        9. The command `scontrol show job` provides diagnostics on job execution issues.
        10. OpenMP is enabled in GCC using the `-fopenmp` flag.
        """
    )
    return


@app.cell
def _():
    import marimo as mo
    return (mo,)


if __name__ == "__main__":
    app.run()

